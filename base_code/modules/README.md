### 进程
进程、线程、锁、原子操作、信号通知  


- 锁   
1、手动操作
mtx.lock() 和 mtx.unlock() 是 std::mutex 的成员函数，用于手动锁定和解锁互斥量

手动控制：需要显式地调用 lock() 来锁定互斥量，并在完成对共享资源的访问后显式地调用 unlock() 来解锁。
异常安全：如果不使用 try_lock()，则 lock() 在无法获取锁时会阻塞直到锁变为可用状态。如果在锁定后发生异常，需要确保在异常传播前解锁互斥量，这通常通过 try-catch 块和 lock_guard 或 finally 代码块来实现。  
资源管理：需要开发者自己管理锁的生命周期，容易出错，比如忘记解锁或者异常退出时没有解锁。      


2、自动
std::unique_lock<std::mutex> 是一个作用域锁定包装器  
锁离开作用域自动释放  
std::lock_guard 没有提供释放锁的操作  
std::unique_lock 可以手动加解锁  


3、wait
1、注意wait执行是会释放所有锁，直到返回值为true才重新获取锁    
2、std::lock_guard<std::mutex> lock(mtx); 会获取锁保护作用区，    
    但特例是和wait一起使用时，不管锁是释放还是使用状态，都会执行到wait     
(1) 锁被其他线程占用，返回false(一般全局变量，用来做状态)，wait会阻塞，等待notify_all         
 通知后或者使用wait_for超时，再次返回true，执行后续      
(2) 锁被释放，返回true，执行后续   

- 线程 
t1.detach(); 分离  
分离后 t2.join();不会阻塞等待

if (t2.joinable()) { // 判断线程是否可被合并或分离
    t2.join();       // 等待线程结束
}

注册信号signal
会阻挡程序获取信号，会等待线程执行完
不注册，主线程退出，其他线程也立即死亡
